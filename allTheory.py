'''
___________________________________________________________________
Семинар № 2 thintax
___________________________________________________________________
'''


num = int(input("Введите число "))
if num % 2 == 0:
    print("вы ввели четное число")
if num % 2 == 1:
    print("Вы ввели нечетное число")

# Код выше не оптемален т.к. используется 1 операнта if
    
    # оперант if используется всегда
    # elif может быть сколько угодно либо не быть вообще
    # else(мусорная куча) все остальные варианты
    # если у нас взаимоисключающие варианты используйте только один оперант

if num == 0: 
    print("Вы ввели ноль")
elif num % 2 == 0: # Проверка на четность
    print("Вы ввели четное число")
else: 
    print("Вы ввели нечетное число")
    
'''
Разница межу циклом for и while:

for -------
перебирает заданное кол-во вариантов(конечная последовательность,
идеально ложиться на работу с коллекциями данных )

while -----
Работает пока не испольниться условие(используем когда мы не знаем что произойдет)
'''

for i in range(10): # range ф-я котора создает некую заданную последовательность(Просим ввести число 10 раз)
    #   внутри range(...) можно использовать 3 значения (старт, конец, шаг)

    num = int(input("Введите число "))
    if num == 0: 
        print("Вы ввели ноль")
    elif num % 2 == 0: # Проверка на четность1
        print("Вы ввели четное число")
    else: 
        print("Вы ввели нечетное число") 
      
    
#while True:  # while True: Бесконечный цикл(опасный)
      
while True:
    num = int(input("Введите число для анализа, для выхода из цикла введите ноль: "))
    if num == 0:
        print("Вы ввели ноль")
        break # останавливает бесконечный цикл while, если мы вводим ноль
    elif num % 2 == 0:
        print("Вы ввели четное число")
    else:
        print("Вы ввели нечетное число")
      
      
      
      
# Метод Флага (flag). Используется вместо while True:

flag = True # Метод флага

while flag: # работает пока flag равен True(До тех пор пока флаг равен истинна, делать :)
    num = int(input("Введите число для анализа, для выхода из цикла введите ноль "))
    if num == 0: 
        print("Вы ввели ноль")
        #break # останавливает бесконечный цикл while, если мы вводим ноль
        flag = False # Используется вместо break(более предпочтителен)
    elif num % 2 == 0: # Проверка на четность1
        print("Вы ввели четное число")
    else: 
        print("Вы ввели нечетное число") 
           
# Флаг: это некий индикатор который принимает либо Treu либо False





'''
______________________________________________________________________
Семинар № 3
______________________________________________________________________
'''


'''
Списки = [] ________________________________________________________
'''

# создание списков
# нельзя называть списки именами зарезервированными питом пр. list, dict и т.д.
sp = list()
sp = [-1, True, 'hello', 5.77, 8.999, "world"]

print(sp)

# Для того чтобы взять некоторую часть списка можно пользоваться срезами

# Срезы работаю в спискообразных коллекциях (строки, списки, кортежи)

print(sp[2:5]) # берем значения со 2 по 4(т.к крайнее значение не берется)

# Итерация по спискам:

# Классический вывод:
for i in range(len(sp)):
    print(f"{i} - {sp[i]}")
   
# 0 - -1
# 1 - True
# 2 - hello
# 3 - 5.77
# 4 - 8.999
# 5 - world

# итерация без индексов
for el in sp:
    print(el, end = ' ') # переменная el превращается в каждый эл-т списка. еnd меняет вывод с построчного в одну строку
    ## -1 True hello 5.77 8.999 world

print(end = '\n')


# методы добавления информации в список:

sp.append('last') # append добавляет в конец
sp.insert(0, 'first') # insert добавляет в любое место(индекс), а все эл-ты справа двигаются
print(sp) 
# ['first', -1, True, 'hello', 5.77, 8.999, 'world', 'last']

# удаление информации из списка

sp.remove(True) # удаляет по значению, только первное вхождение
print(sp)
# ['first', -1, 'hello', 5.77, 8.999, 'world', 'last']
del sp[0] # удаление по индексу
print(sp)
# [-1, 'hello', 5.77, 8.999, 'world', 'last']
a = sp.pop() # вырезает переменную(по умолчанию последню, либо по индексу) которую можно сохранить и потом распечатать
print(a)
# last
print(sp)
# [-1, 'hello', 5.77, 8.999, 'world']




'''
# КОРТЕЖИ = () _______________________________________________ 
(не изменяемая коллекция) быстрее итерируется
'''
# сделаем кортеж t из списка sp
t = tuple(sp)
print(t)
# t[0] = 1
# TypeError: 'tuple' object does not support item assignment(кортеж не дает изменить значение)



'''
# СЛОВАРИ = { } ___________________________________________
совокупность пар: ключ - значение
'''
d = {}
d['дядя ваня'] = 9897775566
d['дядя вася'] = 9996665544
print(d)
# {'дядя ваня': 9897775566, 'дядя вася': 9996665544}
print(d.keys()) # выдать информацию о всех ключах
# dict_keys(['дядя ваня', 'дядя вася'])
print(list(d.keys())) # Превращает только ключи в список

print(d.values()) # выдать информацию о всех значениях
# dict_values([9897775566, 9996665544])

# конструкция in   / Если вы хотите проверить содержиться ли что то в любой коллекции

print('hi' in t)
# False
print('hello' in t)
# True

# можно использовать цикл for для прохода по словарю
for i in d:
    print(i) # переменная i принимает по очереди только значение ключей
# дядя ваня
# дядя вася

# чтобы вывести и ключи и значения ипользуем метод ИНДЕКС

for key, value in d.items(): # вместо key и value можно использовать любые имена
    print(f'{key} - {value}')
# дядя ваня - 9897775566
# дядя вася - 9996665544




'''
# МНОЖЕСТВА = { ,}______________________________________________
# Это не упорядоченная коллекция содержащая уникальные эл-ты
'''

s = {1,1,1,1,5,5,8,8,8,8,8,}
print(s)
# {8, 1, 5}
s.add(7) # добавляет эл-т
print(s)
# {8, 1, 5, 7}
s.discard(1) # безопасно удаляет эл-т
s.discard(2) # т.к. 2 в списке нет discard ни чего не делает
print(s)
print(type(s))
# {8, 5, 7}


# Коллекции можно друг в друга преварщать

# list()  - [] список
# tuple() - () кортеж
# set()   - {} множество


# в словаре пары значений поэтому он не превращается
# dict()  - {} словарь





'''__________________________________________________________________
    СЕМИНАР № 4
   __________________________________________________________________
'''

'''
Библеотеки_______________________________________________________
Это питоновский код написанный ранее, которым можно пользоваться
Есть встроенные в питон
Некоторые устанавливаются отдельно
'''
# Добавление библеотек

import random # Импортируем модуль Рандом(Самая популярная билеотека)
# import random as rnd # Модуль можно переименовать для удобства обращения

# Создадим простой код который будет заполнять список случайными целыми значениями

lst = [] # Создали пустой список
for _ in range(10): # Используем анонимную переменную  "_"
    # Сначала исп-м ф-ю добавления(.append) а внутри нее: 1-м пишем наз-е модуля(random) а 2-м наз-е ф-ии от туда(.randit)
    lst.append(random.randint(1, 100)) # получим случайное целое число от 1 до 100 включительно
    
print(lst)

# Другой вариант
#
from random import randint # Импортируем из модуля random только ф-ю randint(есть риск конфликта имен в большом коде)
# Тогда мы можем писать код без упоминания имени модуля



lst = []
for _ in range(10):
    lst.append(randint(1,100))
print(lst)


# Добавим ф-ю. 
import random as rnd

# Метод это- ф-я приписанная к некому классу
# функция более самостоятельный элемент


# Ф-ю Принято выделать на верх программного кода после блока импорта
# Написание ф-ии начинаем с def (в названии ф-ии рек-ся вначале использовать глагол)
def create_rnd_list(size): # Создаем ф-ю create_rnd_list На входе добавляем переменную size
    lst = [] # Создали пустой список
    for _ in range(size):
        lst.append(rnd.randint(1, 100)) # Создает случайное целое число от 1 до 100
    return lst # Возвращаем значение lst(Возвращает инф-ю в тело основного кода)

print(create_rnd_list(8))

# __________________________________________________________________
# def plus_two_values(v1, v2) # Создаем ф-ю сложения двух значений
def plus_two_values(v1, v2): # Создаем ф-ю и используем анатицию типов данных 
    
    '''
    Напишем справку по этой функции, пр:
    this function add two integer values
    '''
    
    return v1 + v2
# Можно посмотреть справку к функции:
print(plus_two_values.__doc__) # метод Дандер(__doc__)
print(plus_two_values(5,8)) # Запишем работу ф-ии и подадим туда значение
## 13

# ___________________________________________________________________________
#  Создаем ф-ю и используем анатицию типов данных(улучшает читаемость кода)

def plus_two_values(v1: int, v2: int) -> int: # 1-й и 2-й арг. должены быть int и рез-т тоже должен быть int
    
    '''
    Напишем справку по этой функции, пр:
    this function add two integer values
    '''
    # returen v1 + v2
    if isinstance(v1, int) and isinstance(v2, int): # (isinstance)Проверяет являются ли переменные типа int
        return v1 + v2 # если явл-ся то возвращаем значение v1 + v2
    else:
        print("Error!") # Если переменные не типа int выводим Error!

# Либо:_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 


    if not (isinstance(v1, int) and isinstance(v2, int)): # Если хотябы одна перменная не int
        raise TypeError("Must be int values") # то мы генерируем ошибку "Must be int values"
    return v1 + v2

print(plus_two_values(5,8))


# Для помощи можно исп-ю ф-ю:
help(print)


########################################################################################

#  - Функция должна выполнять одну задачу но хорошо
#  - Нельзя создавать ф-ю котороя решает много задач т.к. ф-я основной строительный зл-т
#                                                       кода и она должна быть читаема
#  - Функция может использовать внутри себя другие функции
#  - В назавании ф-ии в начале рекомендуется исп-ть глагол для легкой понимания назначения ф-ии

# ф-ии отделяем друг от друга минимум 1-й пустой строкой
# описания  ф-ии идет после блока импорта


# Тело основного кода принято писать ниже ф-ии на 4 строчки для лучшей читаемости

# Для читаемости Мы можем свою ф-bb написать в отдельном файле
# и ипортировать их в основной код

# T.C  -> 47 min

